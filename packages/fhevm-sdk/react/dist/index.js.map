{"version":3,"sources":["../src/context/FHEVMContext.tsx","../src/context/FHEVMProvider.tsx","../src/hooks/useFHEVM.ts","../src/hooks/useEncrypt.ts","../src/hooks/useDecrypt.ts","../src/hooks/useEncryptBatch.ts"],"names":["createContext","QueryClient","useState","useEffect","FHEVMClient","jsx","QueryClientProvider","useContext","useMutation","coreEncrypt","coreDecrypt","coreEncryptBatch"],"mappings":"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","file":"index.js","sourcesContent":["import { createContext } from 'react'\nimport type { FHEVMClient, FHEVMInstance } from '@universal-fhevm/core'\n\nexport interface FHEVMContextValue {\n  client: FHEVMClient | null\n  instance: FHEVMInstance | null\n  isReady: boolean\n  error: Error | null\n}\n\nexport const FHEVMContext = createContext<FHEVMContextValue>({\n  client: null,\n  instance: null,\n  isReady: false,\n  error: null,\n})\n","import { useEffect, useState, type ReactNode } from 'react'\nimport { FHEVMClient, type FHEVMConfig, type FHEVMInstance } from '@universal-fhevm/core'\nimport { FHEVMContext } from './FHEVMContext'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\n\nexport interface FHEVMProviderProps {\n  config: FHEVMConfig\n  children: ReactNode\n  queryClient?: QueryClient\n}\n\nconst defaultQueryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      refetchOnWindowFocus: false,\n      retry: 1,\n    },\n  },\n})\n\nexport function FHEVMProvider({ config, children, queryClient = defaultQueryClient }: FHEVMProviderProps) {\n  const [client, setClient] = useState<FHEVMClient | null>(null)\n  const [instance, setInstance] = useState<FHEVMInstance | null>(null)\n  const [isReady, setIsReady] = useState(false)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    let mounted = true\n\n    async function initialize() {\n      try {\n        const fhevmClient = new FHEVMClient(config)\n\n        if (config.autoInit !== false) {\n          await fhevmClient.init()\n        }\n\n        if (mounted) {\n          setClient(fhevmClient)\n\n          if (fhevmClient.isReady()) {\n            setInstance(fhevmClient.getInstance())\n            setIsReady(true)\n          }\n        }\n      } catch (err) {\n        if (mounted) {\n          setError(err instanceof Error ? err : new Error(String(err)))\n          setIsReady(false)\n        }\n      }\n    }\n\n    initialize()\n\n    return () => {\n      mounted = false\n    }\n  }, [config])\n\n  const value = {\n    client,\n    instance,\n    isReady,\n    error,\n  }\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <FHEVMContext.Provider value={value}>{children}</FHEVMContext.Provider>\n    </QueryClientProvider>\n  )\n}\n","import { useContext } from 'react'\nimport { FHEVMContext, type FHEVMContextValue } from '../context/FHEVMContext'\n\n/**\n * Hook to access FHEVM instance and client\n */\nexport function useFHEVM(): FHEVMContextValue {\n  const context = useContext(FHEVMContext)\n\n  if (!context) {\n    throw new Error('useFHEVM must be used within FHEVMProvider')\n  }\n\n  return context\n}\n","import { useMutation, type UseMutationOptions } from '@tanstack/react-query'\nimport { encrypt as coreEncrypt, type EncryptParams, type EncryptedData } from '@universal-fhevm/core'\nimport { useFHEVM } from './useFHEVM'\n\nexport interface UseEncryptOptions extends Omit<UseMutationOptions<EncryptedData, Error, EncryptParams>, 'mutationFn'> {\n  userAddress?: string\n}\n\n/**\n * Hook for encrypting values\n */\nexport function useEncrypt(options?: UseEncryptOptions) {\n  const { instance, isReady } = useFHEVM()\n\n  const mutation = useMutation<EncryptedData, Error, EncryptParams>({\n    mutationFn: async (params) => {\n      if (!instance || !isReady) {\n        throw new Error('FHEVM instance is not ready')\n      }\n\n      if (!options?.userAddress) {\n        throw new Error('userAddress is required for encryption')\n      }\n\n      return coreEncrypt(instance, params, options.userAddress)\n    },\n    ...options,\n  })\n\n  return {\n    encrypt: mutation.mutate,\n    encryptAsync: mutation.mutateAsync,\n    isPending: mutation.isPending,\n    isSuccess: mutation.isSuccess,\n    isError: mutation.isError,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset,\n  }\n}\n","import { useMutation, type UseMutationOptions } from '@tanstack/react-query'\nimport { decrypt as coreDecrypt, type DecryptParams } from '@universal-fhevm/core'\nimport { useFHEVM } from './useFHEVM'\n\nexport interface UseDecryptOptions extends Omit<UseMutationOptions<bigint, Error, DecryptParams & { signature: string; userAddress: string; privateKey: string }>, 'mutationFn'> {}\n\n/**\n * Hook for decrypting values\n */\nexport function useDecrypt(options?: UseDecryptOptions) {\n  const { instance, isReady } = useFHEVM()\n\n  const mutation = useMutation<bigint, Error, DecryptParams & { signature: string; userAddress: string; privateKey: string }>({\n    mutationFn: async (params) => {\n      if (!instance || !isReady) {\n        throw new Error('FHEVM instance is not ready')\n      }\n\n      const { signature, userAddress, privateKey, ...decryptParams } = params\n\n      return coreDecrypt(instance, decryptParams, userAddress, privateKey, signature)\n    },\n    ...options,\n  })\n\n  return {\n    decrypt: mutation.mutate,\n    decryptAsync: mutation.mutateAsync,\n    isPending: mutation.isPending,\n    isSuccess: mutation.isSuccess,\n    isError: mutation.isError,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset,\n  }\n}\n","import { useMutation, type UseMutationOptions } from '@tanstack/react-query'\nimport { encryptBatch as coreEncryptBatch, type EncryptBatchParams, type EncryptedData } from '@universal-fhevm/core'\nimport { useFHEVM } from './useFHEVM'\n\nexport interface UseEncryptBatchOptions extends Omit<UseMutationOptions<EncryptedData, Error, EncryptBatchParams>, 'mutationFn'> {\n  userAddress?: string\n}\n\n/**\n * Hook for batch encrypting values\n */\nexport function useEncryptBatch(options?: UseEncryptBatchOptions) {\n  const { instance, isReady } = useFHEVM()\n\n  const mutation = useMutation<EncryptedData, Error, EncryptBatchParams>({\n    mutationFn: async (params) => {\n      if (!instance || !isReady) {\n        throw new Error('FHEVM instance is not ready')\n      }\n\n      if (!options?.userAddress) {\n        throw new Error('userAddress is required for encryption')\n      }\n\n      return coreEncryptBatch(instance, params, options.userAddress)\n    },\n    ...options,\n  })\n\n  return {\n    encryptBatch: mutation.mutate,\n    encryptBatchAsync: mutation.mutateAsync,\n    isPending: mutation.isPending,\n    isSuccess: mutation.isSuccess,\n    isError: mutation.isError,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset,\n  }\n}\n"]}